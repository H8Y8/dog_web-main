{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Project",
        "description": "Set up a new Next.js 14 project with TypeScript support and TailwindCSS configuration.",
        "details": "Use the command `npx create-next-app@latest --typescript` to initialize the project. Install TailwindCSS by following the official documentation for Next.js integration. Ensure to keep the existing TailwindCSS configuration intact.",
        "testStrategy": "Verify that the Next.js application starts without errors and that TailwindCSS styles are applied correctly.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Initialize Next.js Project",
            "description": "Create a new Next.js project using the create-next-app command.",
            "dependencies": [],
            "details": "Run the command 'npx create-next-app@latest my-next-app' to set up the project structure.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure TailwindCSS",
            "description": "Install and configure TailwindCSS in the Next.js project.",
            "dependencies": [
              1
            ],
            "details": "Follow the TailwindCSS installation guide to add Tailwind to your project, including installing dependencies and setting up the configuration files.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Migrate Existing Components",
        "description": "Migrate all existing React components to the Next.js App Router structure.",
        "details": "Move components from the React app to the Next.js app structure. Ensure that each component is properly imported and used in the new layout. Pay special attention to the Navbar and Footer components.",
        "testStrategy": "Check that all components render correctly in the new structure and maintain their original functionality.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "List Navbar Components",
            "description": "Identify all components that make up the Navbar, including links, dropdowns, and branding elements.",
            "dependencies": [],
            "details": "Ensure to note any specific functionality or styling that needs to be preserved during migration.\n<info added on 2025-07-07T06:47:28.350Z>\nNavbar component analysis completed:\nMain findings:\n- use of React Router DOM (Link, useLocation, useNavigate) requiring migration to Next.js navigation\n- state management via useState for mobile menu toggle\n- responsive design for desktop and mobile menus\n- navigation items: /about, /diary, /puppies, /contact\n- active state detection\n- TailwindCSS custom theme colors (earth-600, primary-300, etc.)\n- smooth scrolling feature\n\nMigration requirements:\n1. Replace react-router-dom with next/link and next/navigation\n2. Preserve existing styling and responsive behavior\n3. Adjust route-checking logic for Next.js\n4. Retain all functionality (mobile menu toggle, active states, etc.)\n\nComplexity assessment: Medium (primarily routing system replacement)\n</info added on 2025-07-07T06:47:28.350Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "List Footer Components",
            "description": "Identify all components that make up the Footer, including copyright information, links, and social media icons.",
            "dependencies": [],
            "details": "Document any specific considerations for responsiveness and accessibility in the Footer components.\n<info added on 2025-07-07T06:47:53.656Z>\nFooter component analysis completed:\n\nKey findings:\n- Purely static component with no complex state management\n- TailwindCSS responsive layout (grid-cols-1 on mobile, md:grid-cols-3 on desktop)\n- Three main sections: About, Contact, Social Media Links\n- Inline SVG icons for Facebook, Instagram, and Line\n- Dynamic year display using new Date().getFullYear()\n- External links include target=\"_blank\" and rel=\"noopener noreferrer\"\n- Uses gray-900 background color rather than custom theme colors\n\nComponent structure:\n1. About section: company description text  \n2. Contact section: email, service hotline, business hours, address  \n3. Social Media section: links to Facebook, Instagram, and Line  \n4. Copyright section: dynamic year and copyright notice\n\nMigration requirements:\n- No routing modifications required (no react-router-dom dependency)\n- Preserve existing styling and responsive behavior\n- Retain SVG icons and external link functionality\n- Evaluate unifying background color with custom theme\n\nComplexity assessment: Low (basic static component, straightforward migration)\n</info added on 2025-07-07T06:47:53.656Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Analyze Complexity of Migration",
            "description": "Evaluate the complexity of migrating the identified Navbar and Footer components, considering their structure and functionality.",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a complexity report that outlines potential challenges and required resources for the migration process.\n<info added on 2025-07-07T06:48:42.064Z>\n✅ 組件遷移複雜度分析完成：\n\n## 📊 整體複雜度評估\n\n### 🔥 高複雜度組件 (需要特別注意)\n1. **HeroSlider.jsx** - 複雜度: 7/10\n   - Swiper.js需要客戶端渲染處理\n   - 自定義Ken Burns效果需要保留\n   - 圖片載入優化需要調整為Next.js Image\n\n2. **Admin組件群** - 複雜度: 6-8/10\n   - AdminDashboard, AdminLogin, DiaryEditor, DiaryList\n   - 可能涉及狀態管理和API整合\n   - 需要身份驗證邏輯\n\n### ⚠️ 中等複雜度組件\n1. **Navbar.jsx** - 複雜度: 6/10\n   - React Router → Next.js navigation遷移\n   - 路由檢查邏輯需要重寫\n   - 狀態管理保持不變\n\n2. **ScrollText.jsx** - 複雜度: 5/10\n   - 已使用原生滾動，遷移相對簡單\n   - 複雜的動畫邏輯需要測試\n\n### ✅ 低複雜度組件\n1. **Footer.jsx** - 複雜度: 2/10\n   - 純靜態組件，直接遷移\n\n2. **其他組件** - 複雜度: 2-4/10\n   - About, Certificate, Contact, Diary, Hero, Members, Projects, Puppies\n   - 主要是樣式和少量狀態管理\n\n## 🎯 遷移策略建議\n1. **優先級1**: 先遷移低複雜度組件建立基礎\n2. **優先級2**: 處理Navbar導航系統\n3. **優先級3**: 特殊處理HeroSlider和Admin組件\n4. **預估時間**: 總遷移時間約2-3個工作日\n\n## ⚡ 主要挑戰\n- React Router依賴替換\n- Swiper.js SSR兼容性\n- 圖片優化適配Next.js\n- Admin系統重構\n</info added on 2025-07-07T06:48:42.064Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Setup Layout Component",
        "description": "Create a RootLayout component to wrap all pages and include Navbar and Footer.",
        "details": "Create a new layout file at `app/layout.tsx` that includes the Navbar and Footer components. Ensure that the layout is responsive and maintains the existing styles.",
        "testStrategy": "Test the layout by navigating through different pages to ensure the Navbar and Footer are displayed correctly.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design the RootLayout Component",
            "description": "Create the initial design and structure for the RootLayout component, including header, footer, and main content areas.",
            "dependencies": [],
            "details": "Focus on a clean and modular design that can accommodate various content types. Use CSS Grid or Flexbox for layout.\n<info added on 2025-07-07T06:54:04.667Z>\nNow that the RootLayout structure is in place, implement responsive design optimizations and testing:\n\n• Define and apply TailwindCSS breakpoints (sm, md, lg, xl) across Navbar, main content and Footer  \n• Adjust Navbar menu behavior and layout for mobile (≤640px), tablet (≤768px) and desktop screens  \n• Collapse Footer’s three-column layout into a stacked layout on small viewports and ensure consistent spacing  \n• Ensure the main content area flexibly resizes with appropriate padding and margins at each breakpoint  \n• Test the complete layout on key viewports (e.g. 320px, 768px, 1440px) using both browser dev tools and physical devices  \n• Verify no unexpected layout shifts, maintain SEO metadata/Open Graph tag integrity, and confirm smooth navigation across screen sizes\n</info added on 2025-07-07T06:54:04.667Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Responsive Design",
            "description": "Apply responsive design techniques to the RootLayout component to ensure it works well on different screen sizes.",
            "dependencies": [
              1
            ],
            "details": "Utilize media queries and flexible units (like percentages and viewport units) to adjust the layout for mobile, tablet, and desktop views.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Routing Structure",
        "description": "Establish the routing structure using Next.js App Router.",
        "details": "Create the necessary page files in the `app` directory for Home, About, Environment, Diary, Puppies, Contact, and Admin. Replace all React Router Links with Next.js Link components.",
        "testStrategy": "Verify that all routes are accessible and that navigation works as expected.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Current Routes",
            "description": "Review the existing React Router setup to identify all current routes and their corresponding components.",
            "dependencies": [],
            "details": "List all routes defined in the React Router configuration, including paths and components.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Next.js Pages",
            "description": "For each identified route, create a corresponding page in the Next.js pages directory.",
            "dependencies": [
              1
            ],
            "details": "Ensure that each page is named according to the route structure and includes the necessary component logic.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Replace Links with Next.js Links",
            "description": "Replace all instances of React Router Links with Next.js Link components in the application.",
            "dependencies": [
              2
            ],
            "details": "Ensure that the Link components are properly configured with the correct href attributes and any necessary props.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Migrate TailwindCSS Configuration",
        "description": "Ensure that the existing TailwindCSS configuration is migrated and functional.",
        "details": "Copy the existing TailwindCSS configuration from the React app to the new Next.js project. Ensure that custom colors and styles are preserved.",
        "testStrategy": "Check that all TailwindCSS styles are applied correctly across all components.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Identify Configurations for Migration",
            "description": "Compile a comprehensive list of all configurations that need to be migrated to the new system.",
            "dependencies": [],
            "details": "Review existing documentation and system settings to ensure all configurations are accounted for.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Verify Functionality of Migrated Configurations",
            "description": "Test the functionality of each migrated configuration to ensure they work as intended in the new environment.",
            "dependencies": [
              1
            ],
            "details": "Create test cases for each configuration and document the results to confirm successful migration.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Migrate AOS Animation Library",
        "description": "Integrate the AOS library into the Next.js project and ensure it works with SSR.",
        "details": "Install AOS using `npm install aos`. Import AOS in the layout component and initialize it in a useEffect hook, ensuring to check for `typeof window !== 'undefined'`.",
        "testStrategy": "Test that AOS animations trigger correctly on scroll.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Install AOS Library",
            "description": "Add the AOS library to the Next.js project using npm or yarn.",
            "dependencies": [],
            "details": "Run the command 'npm install aos' or 'yarn add aos' in the terminal to install the AOS library.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Initialize AOS in Next.js",
            "description": "Set up AOS in the Next.js project to ensure it works with server-side rendering.",
            "dependencies": [
              1
            ],
            "details": "Import AOS in the _app.js file and initialize it in a useEffect hook to ensure it runs on the client side. Also, include the AOS CSS in the global styles.\n<info added on 2025-07-07T07:22:06.373Z>\nCreated an AOSInit.tsx client component with the ‘use client’ directive, a useEffect hook to initialize AOS, an SSR compatibility check (typeof window), and animation settings (duration: 1000ms, once: true, offset: 100px). Installed @types/aos for type definitions. Integrated the AOSInit component into layout.tsx. Added fade-down and fade-up test animations on the homepage. AOS is now fully configured and SSR-compatible.\n</info added on 2025-07-07T07:22:06.373Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Migrate Swiper Component",
        "description": "Migrate the HeroSlider component using Swiper.js and ensure Ken Burns effect is preserved.",
        "details": "Install Swiper using `npm install swiper`. Add the 'use client' directive at the top of the HeroSlider component file. Ensure that the Ken Burns effect is implemented correctly using custom CSS.",
        "testStrategy": "Verify that the Swiper component functions correctly and that the Ken Burns effect is visible.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Migrate HeroSlider Component",
            "description": "Transfer the HeroSlider component code to the new framework while ensuring all functionalities are preserved.",
            "dependencies": [],
            "details": "Review the existing HeroSlider code, identify dependencies, and rewrite the component in the new framework syntax. Test the component for basic functionality after migration.\n<info added on 2025-07-07T07:25:58.147Z>\nHeroSlider component migration completed and integrated into the homepage:\n- Created app/components/HeroSlider.tsx with 'use client' directive, all Swiper functionality (autoplay, fade, navigation, pagination) and TypeScript fixes\n- Migrated CSS to app/globals.css (navigation buttons, pagination, Ken Burns animations, responsive styles)\nComponent now prepared for Ken Burns effect implementation.\n</info added on 2025-07-07T07:25:58.147Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Ken Burns Effect",
            "description": "Add the Ken Burns effect to the migrated HeroSlider component to enhance visual appeal.",
            "dependencies": [
              1
            ],
            "details": "Research the Ken Burns effect implementation techniques, integrate the effect into the HeroSlider, and conduct thorough testing to ensure smooth animations and transitions.\n<info added on 2025-07-07T07:26:42.477Z>\nKen Burns effect successfully implemented:\n- getRandomTransform() generates eight translation combinations (–2%, 0, +2% on x/y axes)\n- CSS variables --translate-x and --translate-y are set dynamically via style.setProperty on each slide change\n- @keyframes random-ken-burns defines a 20-second ease animation starting at scale(1.1) and using CSS variables for panning\n- slidechange event listener initializes and recalculates transforms so each image follows a unique movement path\n</info added on 2025-07-07T07:26:42.477Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Migrate ScrollText Component",
        "description": "Migrate the ScrollText component and replace React Scroll functionality with native scrolling.",
        "details": "Remove the React Scroll dependency and implement scrolling using `scrollIntoView` or `window.scrollTo`. Add the 'use client' directive to the ScrollText component.",
        "testStrategy": "Test that the scrolling functionality works as expected and that all animations are intact.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Analyze Current React Scroll Implementation",
            "description": "Review the existing React Scroll functionality to understand how it is integrated and identify the key features that need to be replicated with native scrolling methods.",
            "dependencies": [],
            "details": "Focus on the components and methods used for scrolling, including any props or state management related to scroll behavior.\n<info added on 2025-07-07T07:31:14.544Z>\nScrollText component already uses native scroll APIs without any React Scroll dependency. It features:\n1. native scroll event listeners\n2. complex scroll-based calculation logic\n3. responsive spacing adjustments for mobile, tablet, and desktop\n4. interactive path and dog animation\n5. dynamic opacity and scale effects\n\nMigration steps:\n– add 'use client' directive at the top of the component file  \n– update imports and hooks to comply with Next.js client component requirements  \n– verify native scroll listener binding and cleanup in the Next.js rendering lifecycle  \n– ensure responsive breakpoints and all animations/effects continue to work under the new setup\n</info added on 2025-07-07T07:31:14.544Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Native Scrolling Methods",
            "description": "Replace the identified React Scroll functionality with native scrolling methods, ensuring that all features are preserved and performance is optimized.",
            "dependencies": [
              1
            ],
            "details": "Utilize native JavaScript methods such as scrollTo and scrollIntoView, and ensure compatibility across different browsers.\n<info added on 2025-07-07T07:33:49.167Z>\n1. Created app/components/ScrollText.tsx with 'use client' directive  \n2. Migrated original scrolling logic including complex scroll event handling  \n3. Preserved all original features: responsive design, interactive path, dog animation, dynamic opacity effects  \n4. Added TypeScript typings support  \n5. Updated app/page.tsx to use the new ScrollText component  \n6. Added CSS variables (--primary-400, --primary-500) to global CSS  \n7. Verified functionality by testing on development server\n</info added on 2025-07-07T07:33:49.167Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Create Environment Component",
        "description": "Develop the new Environment component and corresponding page.",
        "details": "Create `Environment.jsx` in the components directory and `environment/page.tsx` in the pages directory. Ensure it follows the design and functionality outlined in the PRD.",
        "testStrategy": "Verify that the Environment page renders correctly and displays the intended content.",
        "priority": "medium",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design the Environment Component",
            "description": "Create a design mockup for the Environment component, considering its layout, color scheme, and user interactions.",
            "dependencies": [],
            "details": "Use design tools like Figma or Sketch to create a visual representation of the component. Ensure it aligns with the overall project theme.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement the Environment Page",
            "description": "Develop the Environment page that utilizes the Environment component, ensuring proper functionality and integration.",
            "dependencies": [
              1
            ],
            "details": "Code the page using the chosen framework (e.g., React, Angular) and ensure it fetches and displays relevant data. Test for responsiveness and usability.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement SEO Features",
        "description": "Add SEO features such as dynamic metadata and sitemap generation.",
        "details": "Utilize Next.js built-in SEO capabilities to set up dynamic metadata for each page. Create a sitemap.xml file for better indexing.",
        "testStrategy": "Check that the metadata is correctly applied and that the sitemap is accessible.",
        "priority": "medium",
        "dependencies": [
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Research Next.js Metadata Capabilities",
            "description": "Investigate how Next.js handles dynamic metadata and the best practices for implementation.",
            "dependencies": [],
            "details": "Look into Next.js documentation and community resources to understand how to set dynamic metadata for pages.\n<info added on 2025-07-07T07:13:25.513Z>\nCompleted research on Next.js metadata features and best practices. Fixed metadata.metadataBase warning by setting the base URL to https://scottish-terrier-kennel.com. Ensured Open Graph and Twitter images parse correctly.\n</info added on 2025-07-07T07:13:25.513Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Dynamic Metadata in Next.js",
            "description": "Set up dynamic metadata for the application based on the research findings.",
            "dependencies": [
              1
            ],
            "details": "Create a function to generate metadata dynamically for each page and ensure it integrates with Next.js routing.\n<info added on 2025-07-07T07:13:31.595Z>\nImplemented basic dynamic metadata configuration, including: setting metadataBase to resolve warnings; configuring complete OpenGraph metadata; setting correct robots and SEO tags; configuring social media sharing tags. Completed Chinese and English titles, descriptions, and keywords for foundational SEO elements.\n</info added on 2025-07-07T07:13:31.595Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create and Test Sitemap",
            "description": "Develop a sitemap for the application and test its correctness for SEO purposes.",
            "dependencies": [
              2
            ],
            "details": "Use a sitemap generation library compatible with Next.js and verify that all routes are included and accessible.\n<info added on 2025-07-07T13:46:36.311Z>\nCompleted implementation and testing of dynamic sitemap and robots.txt:\n- Created app/sitemap.ts using Next.js 14 App Router to generate dynamic sitemap\n- Created app/robots.txt optimized for SEO, referencing the sitemap\n- Removed export settings from Next.js configuration that were affecting dynamic routes\n- Updated sitemap URLs to respect the trailingSlash configuration\n- Verified functionality:\n  • /sitemap.xml returns correctly formatted XML\n  • /robots.txt returns expected content\n  • All page routes are accessible\n  • URL formats align with Next.js configuration\n- Sitemap includes all main pages (Home, About Us, Environment, Blog, New Puppies, Contact Us) with appropriate priority and change frequency\n</info added on 2025-07-07T13:46:36.311Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 11,
        "title": "Setup Supabase Integration",
        "description": "Integrate Supabase for database, authentication, and storage functionalities, including database schema creation (posts, members, puppies, environments), Row-Level Security (RLS) policies, and four storage buckets as specified in the PRD.",
        "status": "done",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "Install the Supabase client using `npm install @supabase/supabase-js`. Configure Supabase in the application: set up authentication, define the database schema with tables for posts, members, puppies, and environments, enable RLS with basic policies, and configure storage services with four buckets per PRD requirements.",
        "testStrategy": "Run smoke tests to validate the Supabase connection; verify authentication flows including JWT token issuance and validation; confirm that the database schema tables exist and RLS policies enforce access controls correctly; test file uploads/downloads in all four storage buckets.",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Supabase Project",
            "description": "Create a new Supabase project through the Supabase dashboard.",
            "status": "done",
            "dependencies": [],
            "details": "Go to the Supabase website, sign in or create an account, and create a new project by providing a name and selecting a database region.",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure Authentication Settings",
            "description": "Set up authentication options in the Supabase project.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Navigate to the 'Authentication' section in the Supabase dashboard, enable email/password sign-up, configure additional providers as needed, and ensure JWT token settings are properly configured.",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Configure Storage Buckets",
            "description": "Configure four storage buckets for file uploads as specified in the PRD.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Go to the 'Storage' section in the Supabase dashboard, create four buckets as specified in the PRD, and set appropriate public or private permissions for each bucket.",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Database Schema",
            "description": "Define tables for posts, members, puppies, and environments in Supabase.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Use the Supabase SQL editor or migrations to create the tables: posts, members, puppies, and environments, including necessary columns, data types, and foreign key relationships.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Configure Row-Level Security (RLS)",
            "description": "Enable RLS and add basic policies for the new tables.",
            "status": "done",
            "dependencies": [
              4
            ],
            "details": "For each table (posts, members, puppies, environments), enable Row-Level Security and create policies that allow authenticated users to select, insert, update, and delete only their own records as appropriate.",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 12,
        "title": "Create API Routes",
        "description": "Establish API routes for managing diary posts, puppies, environment info, and contact forms.",
        "details": "Create API routes in the `pages/api` directory for each required functionality. Implement CRUD operations for diary posts and puppies.",
        "testStrategy": "Test each API route to ensure they respond correctly and perform the intended operations.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define API Routes",
            "description": "Outline the necessary API routes for the application.",
            "dependencies": [],
            "details": "Identify routes for creating, reading, updating, and deleting resources.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Create Operation",
            "description": "Develop the API route for creating new resources.",
            "dependencies": [
              1
            ],
            "details": "Ensure the route accepts necessary data and returns appropriate responses.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Read Operation",
            "description": "Develop the API route for retrieving existing resources.",
            "dependencies": [
              1
            ],
            "details": "Include options for retrieving single or multiple resources.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement Update and Delete Operations",
            "description": "Develop the API routes for updating and deleting resources.",
            "dependencies": [
              1
            ],
            "details": "Ensure routes handle data validation and return correct status codes.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Diary Management System",
        "description": "Develop the diary management system for creating, updating, and deleting diary posts.",
        "details": "Create the necessary components and API routes to manage diary posts. Ensure that users can create, edit, and delete posts.",
        "testStrategy": "Verify that diary posts can be created, updated, and deleted successfully.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Diary Post Model",
            "description": "Create a data model for diary posts that includes fields such as title, content, date, and author.",
            "dependencies": [],
            "details": "The model should be structured to support CRUD operations and include validation rules.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set Up API Routes for Diary Posts",
            "description": "Establish RESTful API routes for creating, reading, updating, and deleting diary posts.",
            "dependencies": [
              1
            ],
            "details": "Routes should include POST /diary, GET /diary/:id, PUT /diary/:id, and DELETE /diary/:id.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Frontend Components for Diary Management",
            "description": "Develop frontend components for displaying, creating, and editing diary posts.",
            "dependencies": [
              2
            ],
            "details": "Components should include a diary list, a diary form, and a diary detail view.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate API with Frontend",
            "description": "Connect the frontend components to the backend API to enable data fetching and manipulation.",
            "dependencies": [
              3
            ],
            "details": "Ensure that the frontend can handle API responses and update the UI accordingly.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement Environment Management System",
        "description": "Develop the environment management system for managing environment information and images.",
        "details": "Create components and API routes for managing environment information. Ensure that images can be uploaded and displayed correctly.",
        "testStrategy": "Test that environment information can be added, updated, and deleted.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Environment Model",
            "description": "Create a data model for storing environment information including fields like name, type, and configuration.",
            "dependencies": [],
            "details": "The model should include validation rules and relationships with other models if necessary.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement API Routes for Environment Management",
            "description": "Set up API routes for CRUD operations on environment information.",
            "dependencies": [
              1
            ],
            "details": "Routes should include GET, POST, PUT, and DELETE methods for managing environments.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Frontend Components for Environment Management",
            "description": "Develop user interface components for displaying and managing environment information.",
            "dependencies": [
              2
            ],
            "details": "Components should allow users to view, add, edit, and delete environments.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Testing and Documentation",
            "description": "Write tests for the API and frontend components, and document the API routes and usage.",
            "dependencies": [
              2,
              3
            ],
            "details": "Ensure that all functionalities are covered and provide clear documentation for future reference.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 15,
        "title": "Implement Puppy Information Management",
        "description": "Develop the puppy information management system for displaying and managing puppy details.",
        "details": "Create components and API routes for managing puppy information. Ensure that all relevant details are displayed correctly.",
        "testStrategy": "Verify that puppy information can be added, updated, and deleted.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Puppy Model",
            "description": "Create a data model for puppies that includes attributes such as name, breed, age, and health status.",
            "dependencies": [],
            "details": "The model should be structured to support CRUD operations and validation rules.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Set Up API Routes",
            "description": "Establish API routes for managing puppy information, including routes for creating, reading, updating, and deleting puppy records.",
            "dependencies": [
              1
            ],
            "details": "Routes should follow RESTful conventions and include error handling.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Puppy Controller",
            "description": "Develop a controller that handles the logic for the API routes defined, including interaction with the puppy model.",
            "dependencies": [
              2
            ],
            "details": "The controller should manage requests and responses, ensuring data integrity.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate Frontend Components",
            "description": "Create frontend components that interact with the API to display and manage puppy information.",
            "dependencies": [
              3
            ],
            "details": "Components should include forms for input and lists for displaying puppy data.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 16,
        "title": "Conduct Performance Optimization",
        "description": "Optimize the application for performance, including image optimization and code splitting.",
        "details": "Utilize Next.js Image component for image optimization. Implement code splitting and caching strategies to enhance performance.",
        "testStrategy": "Measure performance improvements using tools like Lighthouse.",
        "priority": "low",
        "dependencies": [
          10
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Image Optimization Techniques Research",
            "description": "Research various techniques for optimizing images, including compression, format selection, and responsive images.",
            "dependencies": [],
            "details": "Focus on lossless and lossy compression methods, image formats like WebP and JPEG, and how to implement responsive images using srcset.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Image Optimization",
            "description": "Apply the researched image optimization techniques to the project images.",
            "dependencies": [
              1
            ],
            "details": "Use tools like ImageMagick or online services to compress images, convert formats, and implement responsive images in the codebase.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Code Splitting Implementation",
            "description": "Implement code splitting in the project to improve loading times and performance.",
            "dependencies": [
              2
            ],
            "details": "Utilize dynamic imports and configure the build tool (like Webpack) to split the code into smaller chunks that can be loaded on demand.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 17,
        "title": "Deploy Application to Zeabur",
        "description": "Configure and deploy the application to the Zeabur platform.",
        "details": "Set up the deployment environment on Zeabur, configure environment variables, and ensure SSL certificates are in place.",
        "testStrategy": "Verify that the application is accessible on the deployed URL and functions correctly.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set Up Deployment Environment",
            "description": "Configure the server and necessary software for deployment.",
            "dependencies": [],
            "details": "Install required software packages, configure server settings, and ensure network accessibility.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Install SSL Certificate",
            "description": "Obtain and install an SSL certificate on the server.",
            "dependencies": [
              1
            ],
            "details": "Purchase an SSL certificate from a trusted provider, generate a CSR, and install the certificate on the server.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Test SSL Configuration",
            "description": "Verify that the SSL certificate is correctly installed and functioning.",
            "dependencies": [
              2
            ],
            "details": "Use online tools and browser checks to ensure the SSL certificate is valid and the site is accessible via HTTPS.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "Conduct Comprehensive Testing",
        "description": "Perform thorough testing of all functionalities, including unit tests and user acceptance testing.",
        "details": "Create unit tests for critical components and conduct user acceptance testing to ensure all features work as intended.",
        "testStrategy": "Ensure all tests pass and gather user feedback for any necessary adjustments.",
        "priority": "high",
        "dependencies": [
          17
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Unit Testing Strategy",
            "description": "Outline the approach for unit testing, including the frameworks and tools to be used.",
            "dependencies": [],
            "details": "Identify the programming languages and frameworks that will be used for unit testing, such as JUnit for Java or pytest for Python. Specify the criteria for what constitutes a unit test and how tests will be organized.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create User Acceptance Testing Plan",
            "description": "Develop a plan for user acceptance testing (UAT) that outlines the objectives and criteria for success.",
            "dependencies": [],
            "details": "Define the goals of UAT, the target user group, and the acceptance criteria that must be met for the product to be considered acceptable by users.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Develop Unit Test Cases",
            "description": "Create specific unit test cases based on the defined unit testing strategy.",
            "dependencies": [
              1
            ],
            "details": "Write test cases that cover various scenarios for each unit of code, ensuring edge cases and error handling are included.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Conduct User Acceptance Testing",
            "description": "Execute the user acceptance testing plan with real users to validate the product.",
            "dependencies": [
              2
            ],
            "details": "Organize sessions with users to test the product against the acceptance criteria, gather feedback, and document any issues encountered.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 24,
        "title": "Implement CRUD for Posts",
        "description": "Develop the Create, Read, Update, and Delete functionalities for managing posts in the CMS.",
        "details": "Utilize React hooks and Supabase client to implement CRUD operations. Ensure to handle form submissions and state management effectively.",
        "testStrategy": "Test each CRUD operation to ensure data is correctly created, read, updated, and deleted.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Implement Image Upload for Posts",
        "description": "Add functionality for uploading cover images for posts using Supabase storage.",
        "details": "Integrate the `next/image` component for optimized image handling and use Supabase storage for uploading images.",
        "testStrategy": "Verify that images can be uploaded and are correctly associated with the respective posts.",
        "priority": "medium",
        "dependencies": [
          24
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Implement CRUD for Members",
        "description": "Develop the CRUD functionalities for managing members in the CMS.",
        "details": "Similar to posts, implement CRUD operations for members using React hooks and Supabase client.",
        "testStrategy": "Test each CRUD operation for members to ensure data integrity.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Database Migration: Create members Table",
            "description": "Add a new migration to define the members table in Supabase with the specified schema: id, name, breed, birth_date, gender, color, role, status, pedigree_info, health_records, personality_traits, avatar_url, description, achievements, created_at, updated_at.",
            "dependencies": [],
            "details": "Use the Supabase CLI to generate a new SQL migration. In the up script, write CREATE TABLE members (...columns with appropriate types and constraints, primary key on id, timestamps for created_at/updated_at). In the down script, write DROP TABLE members.\n<info added on 2025-07-09T14:45:10.024Z>\nMethod 1: Supabase Dashboard SQL Editor  \nDirectly run the SQL file at database/members-schema-update.sql in Supabase Dashboard > SQL Editor.  \n\nMethod 2: Supabase CLI  \n1. Create a new migration:  \n   supabase migration new update_members_table_for_dogs  \n2. Open the generated migration file and paste the SQL content.  \n\nStep-by-step operations:  \n• Backup existing data:  \n  CREATE TABLE members_backup AS SELECT * FROM members;  \n• Drop the old table:  \n  DROP TABLE IF EXISTS members CASCADE;  \n• Recreate the dog members table with all required columns (name, breed, birth_date, gender, color, role, status, pedigree_info, health_records, achievements, etc.)  \n• Add appropriate indexes for query optimization  \n• Configure Row Level Security (RLS) policies for access control  \n• Insert sample dog member records for testing  \n\nRefer to database/members-schema-update.sql for the full SQL script and use either the Dashboard SQL Editor or the Supabase CLI commands above to execute it.\n</info added on 2025-07-09T14:45:10.024Z>",
            "status": "done",
            "testStrategy": "Run the migration locally and verify the table and column definitions in the Supabase dashboard. Execute sample INSERT and SELECT statements to confirm functionality."
          },
          {
            "id": 2,
            "title": "Define TypeScript Interfaces for Member",
            "description": "Create TypeScript types and interfaces representing the Member entity, matching the new table schema.",
            "dependencies": [
              1
            ],
            "details": "In src/types/member.ts, define an interface Member with fields: id (string), name (string), breed (string), birth_date (string), gender (\"male\"|\"female\"), color (string), role (enum of roles), status (enum of statuses), pedigree_info (string), health_records (string), personality_traits (string), avatar_url (string), description (string), achievements (string), created_at and updated_at (string). Export all types.",
            "status": "done",
            "testStrategy": "Run tsc to ensure no type errors. Create a dummy object of type Member and verify IDE autocomplete and type checking."
          },
          {
            "id": 3,
            "title": "Implement Supabase Data Access Functions",
            "description": "Develop CRUD functions that interact with the Supabase client to perform operations on the members table.",
            "dependencies": [
              1,
              2
            ],
            "details": "In src/lib/api/membersApi.ts, import createClient from @supabase/supabase-js. Write async functions: getMembers(): Promise<Member[]>, getMemberById(id: string): Promise<Member>, createMember(data: Partial<Member>): Promise<Member>, updateMember(id: string, data: Partial<Member>): Promise<Member>, deleteMember(id: string): Promise<void>. Use client.from('members').select()/insert()/update()/delete(). Handle errors by throwing exceptions.",
            "status": "done",
            "testStrategy": "Write simple script or unit tests that call each function against a test database. Verify that data is created, read, updated, and deleted correctly."
          },
          {
            "id": 4,
            "title": "Create React Hooks for Member Operations",
            "description": "Encapsulate the Supabase data access functions in React hooks to manage loading, error, and data state.",
            "dependencies": [
              3
            ],
            "details": "Using a data-fetching library (e.g., react-query or SWR), implement useMembers, useMember(id), useCreateMember, useUpdateMember, useDeleteMember. Each hook should call the corresponding API function, return {data, error, isLoading}, and invalidate caches on mutations.",
            "status": "done",
            "testStrategy": "Mock the membersApi functions and test that the hooks invoke them correctly. Verify loading and error states in unit tests using React Testing Library."
          },
          {
            "id": 5,
            "title": "Implement Member Creation Form UI",
            "description": "Build a React component with a form to create new members, using useCreateMember hook and TypeScript types.",
            "dependencies": [
              4
            ],
            "details": "In src/components/MemberForm/CreateMemberForm.tsx, use React Hook Form to render inputs for all member fields. Validate required fields. For avatar_url, integrate file upload or URL input. On submit, call useCreateMember.mutate with form data, show success toast or error message, and redirect or reset form.",
            "status": "done",
            "testStrategy": "Write integration tests: render form, fill fields, submit, mock API to succeed or fail, assert UI feedback and form reset/redirection."
          },
          {
            "id": 6,
            "title": "Implement Member Listing and Detail View",
            "description": "Create components to list all members in a table or grid and show detailed information on selection.",
            "dependencies": [
              4
            ],
            "details": "In src/components/MemberList/MemberList.tsx, use useMembers to fetch data, display name, breed, role, status in a table with pagination. Each row links to /members/:id. In src/pages/members/[id].tsx, use useMember to fetch by ID and render all fields including avatar and health records.",
            "status": "done",
            "testStrategy": "Write UI tests to confirm the list loads items and pagination works. For detail view, mock hook to return a Member and verify all fields render correctly."
          },
          {
            "id": 7,
            "title": "Implement Member Edit and Delete Features",
            "description": "Extend the detail view with editing and deletion capabilities using useUpdateMember and useDeleteMember hooks.",
            "dependencies": [
              6
            ],
            "details": "In the detail page component, add an Edit button that opens the CreateMemberForm pre-filled with current member data, then calls useUpdateMember.mutate on submit. Add a Delete button that prompts for confirmation, then calls useDeleteMember.mutate and navigates back to the list on success.",
            "status": "done",
            "testStrategy": "Test that editing updates the record in the mock API and the UI reflects changes. Test delete flow with confirmation modal and verify navigation and API call."
          }
        ]
      },
      {
        "id": 27,
        "title": "Implement Image Upload for Members",
        "description": "Add functionality for uploading avatars for members using Supabase storage.",
        "details": "Utilize the same image upload strategy as posts for member avatars, ensuring proper handling and storage.",
        "testStrategy": "Verify that member avatars can be uploaded and displayed correctly.",
        "priority": "medium",
        "dependencies": [
          26
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Configure Supabase Storage Bucket and Database Schema for Member Photos",
            "description": "Set up the Supabase storage bucket 'member_photos' and update the members database table to include fields for avatar_url, album_urls, pedigree_urls, and health_check_urls.",
            "dependencies": [],
            "details": "In the Supabase dashboard or via CLI, create a new storage bucket named 'member_photos'. In your database migration, alter the 'members' table to add columns: avatar_url (text), album_urls (text[]), pedigree_urls (text[]), health_check_urls (text[]). Set up RLS policies to allow authenticated users to upload and read their own files.",
            "status": "done",
            "testStrategy": "Verify bucket existence and column additions via Supabase UI or CLI; manually test RLS policies by attempting uploads, reads, and unauthorized access."
          },
          {
            "id": 2,
            "title": "Develop Backend API Endpoints for Photo Upload and Management",
            "description": "Implement server-side API routes to handle uploading, deleting, and retrieving member photos of different types in the 'member_photos' bucket.",
            "dependencies": [
              1
            ],
            "details": "Create RESTful endpoints under '/members/:memberId/photos'. Use the Supabase client to upload files to 'member_photos' at path '{memberId}/{type}/{uuid}'. On upload success, update the member record: replace avatar_url or append/remove entries in album_urls, pedigree_urls, or health_check_urls arrays. Implement DELETE endpoints to remove files from storage and update DB columns accordingly.",
            "status": "done",
            "testStrategy": "Write unit tests for upload and delete endpoints, mocking the Supabase client to assert correct storage paths and DB mutations; perform integration tests uploading and deleting actual files."
          },
          {
            "id": 3,
            "title": "Integrate Client-Side Image Compression and Optimization",
            "description": "Add an image compression library to the project and implement helper functions to compress and optimize images before uploading.",
            "dependencies": [
              1
            ],
            "details": "Install a library such as 'browser-image-compression'. Create a helper function that accepts a File object, compresses it to a specified maximum size/quality, and returns a Blob or File ready for upload. Ensure support for JPEG, PNG, and WebP formats.",
            "status": "done",
            "testStrategy": "Write unit tests that pass sample image files into the helper and assert that output file sizes are reduced and image integrity is maintained."
          },
          {
            "id": 4,
            "title": "Build Drag-and-Drop Upload Component",
            "description": "Create a reusable frontend component with drag-and-drop and file input fallback, allowing users to select images and choose photo types.",
            "dependencies": [
              3
            ],
            "details": "Using your frontend framework (e.g., React or Vue), build a component containing a drop zone for file input, a photo type selector (avatar, album, pedigree, health_check), and thumbnail previews of selected files. Include accessible labels and keyboard interactions.",
            "status": "done",
            "testStrategy": "Manually verify drag-and-drop and file selection for each photo type; write snapshot tests to ensure consistent rendering of the component."
          },
          {
            "id": 5,
            "title": "Integrate Upload Component with Backend API",
            "description": "Wire the drag-and-drop component to call the backend API, using the compression helper, and handle responses to update UI state.",
            "dependencies": [
              2,
              4
            ],
            "details": "In the upload component, on file drop or selection, call the compression helper, then send a POST request to '/members/{memberId}/photos' with multipart/form-data including the compressed file and photo type. Manage loading states, catch errors, and update component state or invoke callbacks with the new photo URLs on success.",
            "status": "done",
            "testStrategy": "Write integration tests simulating file uploads with mocked API responses; verify that the UI displays loading states, handles errors properly, and updates previews on success."
          },
          {
            "id": 6,
            "title": "Implement Photo Preview and Management Interface",
            "description": "Display uploaded photos categorized by type, allow deleting and reordering (for album), and updating the avatar and other types.",
            "dependencies": [
              5
            ],
            "details": "On the member profile or edit page, fetch photo URLs and render sections for avatar (single image), album (grid with drag-to-reorder), pedigree, and health check (galleries). Implement delete buttons that call DELETE endpoints and update the UI. For album photos, enable drag-and-drop reordering and persist the new order via a PATCH endpoint.",
            "status": "done",
            "testStrategy": "Perform end-to-end tests: upload each photo type, verify display, delete photos and confirm removal, reorder album photos and verify order is saved correctly."
          }
        ]
      },
      {
        "id": 28,
        "title": "Implement CRUD for Puppies",
        "description": "Develop the CRUD functionalities for managing puppies in the CMS.",
        "details": "Implement CRUD operations for puppies, ensuring to include the available toggle feature as specified in the PRD.",
        "testStrategy": "Test each CRUD operation for puppies to ensure data integrity.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 29,
        "title": "Implement Image Upload for Puppies",
        "description": "Add functionality for uploading images for puppies using Supabase storage.",
        "details": "Implement image upload functionality similar to posts and members for puppy images.",
        "testStrategy": "Verify that puppy images can be uploaded and displayed correctly.",
        "priority": "medium",
        "dependencies": [
          28
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 30,
        "title": "Implement CRUD for Environments",
        "description": "Develop the CRUD functionalities for managing environments in the CMS.",
        "details": "Implement CRUD operations for environments, ensuring to handle multiple image uploads as specified in the PRD.",
        "testStrategy": "Test each CRUD operation for environments to ensure data integrity.",
        "priority": "high",
        "dependencies": [
          "11"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 31,
        "title": "Implement Image Upload for Environments",
        "description": "Add functionality for uploading images for environments using Supabase storage.",
        "details": "Utilize the same image upload strategy as posts and members for environment images.",
        "testStrategy": "Verify that environment images can be uploaded and displayed correctly.",
        "priority": "medium",
        "dependencies": [
          30
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 32,
        "title": "Implement Supabase Auth",
        "description": "Completed integration of Supabase authentication for user login, session management, and admin role management in the CMS.",
        "status": "done",
        "dependencies": [
          "11"
        ],
        "priority": "high",
        "details": "• lib/auth.ts: login/logout, session management, admin permission checks, admin user creation\n• lib/hooks/useAuth.ts: React hook for auth logic, auto state handling, helper functions\n• app/admin/page.tsx: real Supabase auth, admin permission enforcement, loading and error states, email login\n• lib/admin-setup.ts: development‐mode quick setup, custom admin creation, error handling\n• app/admin/setup/page.tsx: visual UI for admin creation, quick and custom setup flows, user feedback\n• Security: JWT stored in HttpOnly cookies, permission checks, robust error handling\n• Usage: 1) Visit /admin/setup to create an admin user; 2) Visit /admin to log in; 3) Default test account: admin@example.com / admin123456",
        "testStrategy": "Verify full authentication flows: login, logout, session persistence, admin setup UI, role‐based access control, error handling, and JWT cookie security.",
        "subtasks": []
      },
      {
        "id": 33,
        "title": "Modernize Admin Dashboard UI with Design System and Responsive Features",
        "description": "Redesign the admin dashboard UI with a modern design language, implement a responsive, component-based design system, optimize navigation and information architecture, and add dark mode and interactive states.",
        "details": "1. Redesign the entire admin interface using a modern UI language (e.g., TailwindCSS v3, Figma-to-code workflows). Define design tokens (color palette, typography scales, spacing, and shadows).\n2. Build a unified component library (buttons, forms, modals, tables, cards, alerts) and a living design system documented in Storybook.\n3. Implement responsive layouts with CSS Grid and Flexbox to support desktop and tablet breakpoints (>=1024px, >=768px).\n4. Optimize navigation structure and information architecture: define main sections, sub-sections, and user flows.\n5. Develop sidebar navigation with collapsible menus, top navigation bar with user actions, and breadcrumb components to reflect route hierarchy.\n6. Design data display screens: responsive tables with sorting/pagination, card-based dashboard widgets, and interactive charts (e.g., using Recharts or Chart.js).\n7. Add dark mode support using CSS variables or Tailwind theming; ensure smooth theme switching.\n8. Implement interactive states: skeleton loaders for data fetching, spinner and progress indicators, error banners and state views, and form validation feedback.\n9. Ensure accessibility (ARIA labels, keyboard navigation, contrast ratios) and cross-browser compatibility.",
        "testStrategy": "1. Validate responsive behavior by testing in browser dev tools at desktop and tablet breakpoints.\n2. Use Storybook to test component variations, dark mode, and accessibility checks with axe.\n3. Manually verify sidebar, top nav, and breadcrumb navigation across key routes.\n4. Simulate loading and error states using network throttling and mock API failures; confirm skeletons and error banners display correctly.\n5. Review design tokens against Figma designs for color and typography consistency.\n6. Conduct cross-browser testing on Chrome, Firefox, Safari, and Edge.\n7. Gather UI feedback from stakeholders to ensure improved user experience.",
        "status": "done",
        "dependencies": [
          1,
          11,
          32
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 34,
        "title": "Implement Front-End Posts Display on Blog Page",
        "description": "Build the front-end functionality to fetch and display CMS posts on the public blog page, including list view, pagination, and filtering, fully synchronized with back-end CRUD operations.",
        "details": "1. Create or update the blog listing page (e.g., app/posts/page.tsx) to fetch posts from Supabase via the existing posts table APIs.\n2. Implement list rendering using the shared design system’s card or list components, displaying title, excerpt, author, date, and thumbnail.\n3. Add pagination controls: use limit and offset (or cursor) queries to fetch pages of posts; implement Previous/Next and page number buttons.\n4. Implement filtering controls (e.g., by category, tag, or search keyword): wire filter inputs to API queries and update the displayed list.\n5. Handle loading and error states with UI feedback (skeleton loaders, error messages).\n6. Ensure real-time synchronization by re-fetching or subscribing to changes so front-end reflects CRUD updates immediately.\n7. Apply responsive styles for mobile, tablet, and desktop breakpoints using the design system’s grid and utility classes.\n8. Ensure accessibility: proper semantic markup, keyboard navigation, and ARIA attributes for pagination and filters.",
        "testStrategy": "1. Verify initial page load fetches and displays correct posts sorted by date.\n2. Test pagination: navigate between pages, ensure correct posts load, and controls disable appropriately at bounds.\n3. Test filtering: apply each filter and search term, confirm displayed results match criteria and URL reflects filter state.\n4. Simulate CRUD changes in the admin (Task 24) and confirm the front-end updates (on refresh or real-time) to reflect new, updated, or deleted posts.\n5. Check responsive behavior at key breakpoints (mobile, tablet, desktop).\n6. Run accessibility audit (e.g., axe) on pagination and filter controls.\n7. Test error handling by mocking API failures and verifying user-friendly error messages.",
        "status": "done",
        "dependencies": [
          24
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 35,
        "title": "Implement Front-End Members Display on About Us Page",
        "description": "Fetch and display member data managed in the admin CMS on the public About Us page, including member list, role-based grouping, and individual biographies, fully synchronized with the back-end CRUD and image upload features.",
        "details": "1. Create or update the About Us page (e.g., app/about/page.tsx) to fetch member records from Supabase (members table) via the existing CRUD API. Select fields: id, name, role, bio, avatar_url.\n2. Use the design system’s card or list components to render each member’s avatar, name, role, and biography. Ensure responsive layout (grid on desktop, list on mobile).\n3. Implement role-based filtering or tabs (e.g., “All”, “Developers”, “Designers”) that group members by their role. When a filter is active, display only matching members.\n4. Handle loading states (skeleton cards) and error states (friendly error message and retry button).\n5. Subscribe to Supabase real-time updates on the members table or re-fetch on page navigation to ensure the front-end display stays in sync with CRUD operations and image uploads.\n6. Ensure accessibility: use semantic HTML, ARIA labels for filters, and alt text for avatars.",
        "testStrategy": "1. Verify initial page load fetches and displays all members sorted by name, showing avatar, role, and bio.\n2. Test each role filter/tab: click to filter, confirm only members with that role appear.\n3. Perform member add, update, and delete operations in the admin CMS and confirm the About Us page reflects changes on refresh and via real-time updates.\n4. Upload or change a member avatar in the admin CMS and verify the updated image appears on the About Us page.\n5. Simulate loading (slow network) and server error states to confirm skeletons and error UI appear as expected.\n6. Check responsive layout at multiple breakpoints and run basic accessibility audit (keyboard navigation, screen reader labels).",
        "status": "done",
        "dependencies": [
          26,
          27
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup Dog Members Page and Data Fetching",
            "description": "Create or update the Dog Members page (e.g., app/members/page.tsx) to fetch dog member records from Supabase using the existing CRUD API. Select fields: id, name, role, bio, avatar_url, pedigree, health_status, personality, achievements, gallery_urls, certificate_urls.",
            "dependencies": [],
            "details": "In app/members/page.tsx, import the Supabase client instance and define a fetchMembers function that queries the 'members' table selecting the specified fields. Use getServerSideProps or a client data‐fetching hook (e.g., useSWR) to retrieve data. Export the page component skeleton returning fetched props or hook data.",
            "status": "done",
            "testStrategy": "Unit test fetchMembers with a mocked Supabase client to verify correct query. Integration test by mocking API responses and asserting data is passed to the page component."
          },
          {
            "id": 2,
            "title": "Implement DogMemberCard Component",
            "description": "Build a reusable DogMemberCard component to display each dog's avatar, name, role, pedigree, health status, personality, and achievements in a card layout.",
            "dependencies": [
              1
            ],
            "details": "Create components/DogMemberCard.tsx. Accept a DogMember prop interface. Use the design system Card or styled divs. Render avatar with alt text, name as an h3, role as subtitle, and structured sections for pedigree, health_status, personality, and achievements. Ensure semantic HTML and responsive styling.",
            "status": "done",
            "testStrategy": "Unit test with React Testing Library: render DogMemberCard with sample props and assert presence of each field and correct alt attributes."
          },
          {
            "id": 3,
            "title": "Add Role-based Filtering and Tabs",
            "description": "Implement filter controls (tabs) to group and display dogs by role (breeding_male, breeding_female, training, retired, All).",
            "dependencies": [
              2
            ],
            "details": "In the page component, derive the set of roles from fetched data. Implement an accessible Tabs component (using ARIA roles) for each role. On tab selection update a filter state and render only DogMemberCard components matching the selected role, or all when ‘All’ is active.",
            "status": "done",
            "testStrategy": "Unit test tab interactions: simulate tab clicks and assert that only cards with matching roles are rendered."
          },
          {
            "id": 4,
            "title": "Implement Loading, Error Handling, and SEO",
            "description": "Add loading skeletons, error states with retry, and SEO meta tags for the Dog Members page.",
            "dependencies": [
              2
            ],
            "details": "Wrap data fetching in useSWR or custom hook. While loading, render skeleton versions of DogMemberCard. On fetch error display a friendly message and a Retry button that re‐invokes the fetch. Use next/head to set meta title, description, and Open Graph tags reflecting the dog members content for SEO.",
            "status": "done",
            "testStrategy": "Mock data fetch pending and error states to test loading skeletons and error UI. Use a head tag inspection in integration tests to verify correct meta tags."
          },
          {
            "id": 5,
            "title": "Integrate Real-time Sync and Gallery/Certificates Display",
            "description": "Subscribe to Supabase real-time updates on the members table to keep the page in sync, and extend DogMemberCard to display photo galleries and certificate thumbnails.",
            "dependencies": [
              3,
              4
            ],
            "details": "In the data fetch hook or page component, initialize a Supabase channel subscription on the 'members' table for INSERT, UPDATE, DELETE events to trigger data revalidation or state updates. In DogMemberCard, render a carousel or grid of images from gallery_urls and badge thumbnails linked to certificate_urls. Ensure accessibility of carousel controls and image alt text.",
            "status": "done",
            "testStrategy": "Use end-to-end tests with Supabase emulator to emit real-time events and verify UI updates automatically. Test gallery/carousel renders all images and alt texts correctly."
          }
        ]
      },
      {
        "id": 36,
        "title": "Implement Front-End Puppies Display on New Puppies Page",
        "description": "Fetch and display puppy records from the CMS on the public New Puppies page, including listing, sale status filtering, and detailed views, fully synchronized with the backend CRUD and image upload features.",
        "details": "1. Create or update the New Puppies page (e.g., app/puppies/page.tsx) to fetch puppy records from Supabase (puppies table) via the existing CRUD API. Query fields: id, name, breed, age, price, status, image_url, description.\n2. Use the design system’s card or list components to render each puppy’s image, name, breed, age, price, and sale status. Ensure a responsive grid layout on desktop and list view on mobile.\n3. Implement sale status filter controls (e.g., tabs or dropdown: All, Available, Sold) that apply server-side filtering via query parameters.\n4. Add clickable puppy cards that navigate to a detailed puppy page (e.g., app/puppies/[id]/page.tsx). Fetch and display detailed information including description, additional images, and pedigree details.\n5. Handle loading, error, and empty states with spinners, alerts, and fallback messages.\n6. Optimize image loading using next/image or equivalent with lazy loading.\n7. Ensure front-end reflects back-end CRUD changes: test by adding, updating, and deleting puppies in the admin CMS and verifying updates refresh on the public page.",
        "testStrategy": "1. Load the New Puppies page and verify all puppies from the CMS display correctly with images, names, breeds, ages, prices, and statuses.\n2. Test sale status filters by selecting each option and confirming correct puppies are shown.\n3. Click a puppy card to open its detail page; verify detailed information and images display correctly.\n4. Perform add/update/delete operations in the admin CMS and confirm the public page and detail views reflect changes after reload.\n5. Test responsive behavior across breakpoints (mobile, tablet, desktop).\n6. Simulate network delays/failures to verify loading and error states display appropriate UI feedback.",
        "status": "pending",
        "dependencies": [
          28,
          29
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 37,
        "title": "Implement Front-End Environments Display on Environment Introduction Page",
        "description": "Fetch and display environment information managed in the CMS on the public Environment Introduction page, including type categories, image carousel, and facility highlights, fully synchronized with backend CRUD and image upload.",
        "details": "1. Create or update the public Environment Introduction page (e.g., app/environments/page.tsx) to use the existing Environment component as a template.\n2. Fetch environment records from the Supabase environments table via the CRUD API endpoints implemented in Task 30. Query fields: id, name, type, description, images (array of URLs), and features (facility icon identifiers and descriptions).\n3. Implement type category tabs or filter controls to group and display environments by their type (e.g., indoor, outdoor).\n4. For each environment entry, render an image carousel using the design system’s carousel component, displaying all associated images from Task 31 with next/previous controls and pagination indicators.\n5. Display facility features as icon-and-text pairs beneath the carousel, pulling icon assets from the design system’s icon library.\n6. Handle loading states with a spinner or skeleton UI, and show user-friendly error messages if the fetch fails.\n7. Ensure a responsive layout: use a grid display on desktop (≥1024px) and a stacked layout on mobile (<768px), adhering to design system breakpoints.\n8. Reuse existing design tokens and styling conventions (colors, typography, spacing) to maintain consistency across the site.",
        "testStrategy": "1. Load the Environment Introduction page and verify it fetches and displays all environments from the CMS, grouped correctly by type.\n2. Click each type filter/tab and confirm that only environments of the selected type are shown.\n3. Within each environment, navigate the image carousel; ensure all images load, controls (prev/next) work, and indicators update correctly.\n4. Check that facility features (icons and descriptions) are displayed accurately for each environment.\n5. Perform add, update, and delete operations on environment records and images in the admin CMS (Tasks 30 and 31); refresh the public page to confirm that changes are reflected in real time.\n6. Test the page on desktop and mobile viewport sizes to verify responsive behavior.\n7. Use an accessibility audit tool (e.g., axe) to confirm carousel controls, filter tabs, and content meet WCAG AA standards.",
        "status": "pending",
        "dependencies": [
          9,
          30,
          31
        ],
        "priority": "medium",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-05T16:25:31.127Z",
      "updated": "2025-07-09T16:27:12.760Z",
      "description": "Tasks for master context"
    }
  }
}